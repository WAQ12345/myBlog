<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>åœ£è¯æ ‘</title>
    <style>
      * {
        -webkit-tap-highlight-color: transparent;
      }
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000000;
        font-family: 'Times New Roman', serif;
        touch-action: none;
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      /* UI Overlay */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-top: 30px;
        box-sizing: border-box;
      }

      /* Loading */
      #loader {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.8s ease-out;
      }
      .loader-text {
        color: #d4af37;
        font-size: 14px;
        letter-spacing: 4px;
        margin-top: 20px;
        text-transform: uppercase;
        font-weight: 100;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 1px solid rgba(212, 175, 55, 0.2);
        border-top: 1px solid #d4af37;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Typography */
      h1 {
        color: #fceea7;
        font-size: 32px;
        margin: 0;
        font-weight: 400;
        letter-spacing: 4px;
        text-shadow: 0 0 50px rgba(252, 238, 167, 0.6);
        background: linear-gradient(to bottom, #fff, #eebb66);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        font-family: 'Cinzel', 'Times New Roman', serif;
        opacity: 0.9;
      }

      /* Upload Button */
      .upload-wrapper {
        margin-top: 15px;
        pointer-events: auto;
        text-align: center;
      }
      .upload-btn {
        background: rgba(20, 20, 20, 0.6);
        border: 1px solid rgba(212, 175, 55, 0.4);
        color: #d4af37;
        padding: 10px 20px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 2px;
        font-size: 10px;
        transition: all 0.4s;
        display: inline-block;
        backdrop-filter: blur(5px);
      }
      .upload-btn:active {
        background: #d4af37;
        color: #000;
      }
      .hint-text {
        color: rgba(212, 175, 55, 0.6);
        font-size: 10px;
        margin-top: 10px;
        letter-spacing: 1px;
      }
      #file-input {
        display: none;
      }

      /* æ§åˆ¶æŒ‰é’®ç»„ */
      .control-buttons {
        margin-top: 20px;
        pointer-events: auto;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .control-btn {
        background: rgba(20, 20, 20, 0.7);
        border: 1px solid rgba(212, 175, 55, 0.5);
        color: #d4af37;
        padding: 10px 16px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 11px;
        transition: all 0.3s;
        border-radius: 4px;
        backdrop-filter: blur(5px);
        user-select: none;
        -webkit-user-select: none;
      }
      .control-btn:active,
      .control-btn.active {
        background: #d4af37;
        color: #000;
        border-color: #d4af37;
      }
      .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* å“åº”å¼ */
      @media screen and (max-width: 480px) {
        h1 {
          font-size: 26px;
          letter-spacing: 2px;
        }
        #ui-layer {
          padding-top: 20px;
        }
        .upload-btn {
          padding: 8px 16px;
          font-size: 9px;
        }
        .control-btn {
          padding: 8px 12px;
          font-size: 10px;
        }
        .control-buttons {
          gap: 8px;
          margin-top: 15px;
        }
      }

      @media screen and (max-height: 500px) and (orientation: landscape) {
        h1 {
          font-size: 22px;
        }
        #ui-layer {
          padding-top: 10px;
        }
        .upload-wrapper {
          margin-top: 8px;
        }
        .control-buttons {
          margin-top: 10px;
        }
      }

      /* æ‘„åƒå¤´é¢„è§ˆ */
      #webcam {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 160px;
        height: 120px;
        border: 2px solid rgba(212, 175, 55, 0.6);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.8);
        z-index: 20;
        object-fit: cover;
        transform: scaleX(-1); /* é•œåƒæ˜¾ç¤ºï¼Œæ›´ç¬¦åˆç”¨æˆ·ä¹ æƒ¯ */
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
      }

      @media screen and (max-width: 480px) {
        #webcam {
          width: 120px;
          height: 90px;
          bottom: 15px;
          right: 15px;
        }
      }
    </style>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
          "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm",
          "three-unpkg": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three-addons-unpkg/": "https://unpkg.com/three@0.160.0/examples/jsm/",
          "three-cdnjs": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.module.min.js",
          "three-addons-cdnjs/": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/examples/jsm/",
          "three-bootcdn": "https://cdn.bootcdn.net/ajax/libs/three.js/0.160.0/three.module.min.js",
          "three-addons-bootcdn/": "https://cdn.bootcdn.net/ajax/libs/three.js/0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="loader">
      <div class="spinner"></div>
      <div class="loader-text">åŠ è½½ä¸­...</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
      <h1>Merry Christmas</h1>

      <div class="upload-wrapper">
        <label class="upload-btn">
          æ·»åŠ ç…§ç‰‡
          <input type="file" id="file-input" multiple accept="image/*" />
        </label>
        <div class="hint-text" id="hint-text">
          ğŸ–ï¸ å¼ å¼€æ•£å¼€ Â· âœŠ æ¡æ‹³åˆæ‹¢ Â· ğŸ¤ æåˆèšç„¦ Â· ğŸ‘ åˆ‡æ¢é¢œè‰²
        </div>
      </div>

      <!-- æŒ‰é’®æ§åˆ¶ï¼ˆæ— æ‘„åƒå¤´æ—¶æ˜¾ç¤ºï¼‰ -->
      <div class="control-buttons" id="control-buttons" style="display: none">
        <button class="control-btn" id="btn-tree" data-mode="TREE">ğŸŒ² æ ‘å½¢</button>
        <button class="control-btn" id="btn-scatter" data-mode="SCATTER">âœ¨ æ•£å¼€</button>
        <button class="control-btn" id="btn-focus" data-mode="FOCUS">ğŸ¯ èšç„¦</button>
      </div>
    </div>

    <!-- æ‘„åƒå¤´é¢„è§ˆç”¨äºæ‰‹åŠ¿è¯†åˆ« -->
    <video id="webcam" autoplay playsinline></video>

    <script type="module">
      // å…¨å±€é”™è¯¯å¤„ç†å’Œè¶…æ—¶ä¿æŠ¤
      let THREE,
        EffectComposer,
        RenderPass,
        UnrealBloomPass,
        RoomEnvironment,
        FilesetResolver,
        HandLandmarker

      // æ›´æ–°åŠ è½½æç¤º
      function updateLoaderText(text) {
        const loaderText = document.querySelector('.loader-text')
        if (loaderText) {
          loaderText.textContent = text
        }
      }

      // èµ„æºåŠ è½½è¶…æ—¶åŒ…è£…å‡½æ•°ï¼ˆæ”¯æŒå¤šä¸ªå¤‡ç”¨CDNä¾æ¬¡å°è¯•ï¼‰
      async function loadWithTimeout(
        importPromise,
        timeout = 30000,
        resourceName = 'èµ„æº',
        fallbackImports = [],
      ) {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent,
        )
        // ç§»åŠ¨ç«¯ä½¿ç”¨5ç§’è¶…æ—¶
        const actualTimeout = isMobile ? 5000 : timeout

        // æ‰€æœ‰CDNæºï¼ˆä¸»CDN + å¤‡ç”¨CDNï¼‰
        const allSources = [importPromise, ...fallbackImports]
        const cdnNames = ['jsdelivr', 'unpkg', 'cdnjs', 'bootcdn']

        updateLoaderText(`æ­£åœ¨åŠ è½½ ${resourceName}...`)

        for (let attempt = 0; attempt < allSources.length; attempt++) {
          const currentImport =
            typeof allSources[attempt] === 'function' ? allSources[attempt]() : allSources[attempt]
          const cdnName = attempt === 0 ? 'ä¸»CDN' : cdnNames[attempt] || `å¤‡ç”¨CDN${attempt}`

          const timeoutPromise = new Promise((_, reject) =>
            setTimeout(
              () => reject(new Error(`${resourceName}åŠ è½½è¶…æ—¶(${actualTimeout / 1000}ç§’)`)),
              actualTimeout,
            ),
          )

          try {
            updateLoaderText(`æ­£åœ¨ä»${cdnName}åŠ è½½ ${resourceName}...`)
            const result = await Promise.race([currentImport, timeoutPromise])
            updateLoaderText('åŠ è½½ä¸­...')
            if (attempt > 0) {
              console.log(`${resourceName}ä»${cdnName}åŠ è½½æˆåŠŸ`)
            }
            return result
          } catch (err) {
            console.warn(`${resourceName}ä»${cdnName}åŠ è½½å¤±è´¥:`, err.message || err)
            if (attempt < allSources.length - 1) {
              updateLoaderText(
                `${resourceName}åŠ è½½å¤±è´¥ï¼Œå°è¯•${cdnNames[attempt + 1] || 'ä¸‹ä¸€ä¸ª'}CDN...`,
              )
              // ç­‰å¾…1ç§’åå°è¯•ä¸‹ä¸€ä¸ªCDN
              await new Promise((resolve) => setTimeout(resolve, 1000))
              continue
            }
            // æ‰€æœ‰CDNéƒ½å¤±è´¥äº†
            console.error(`${resourceName}æ‰€æœ‰CDNåŠ è½½å¤±è´¥`)
            throw new Error(`${resourceName}æ‰€æœ‰CDNåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥`)
          }
        }
      }

      // åŠ è½½èµ„æºï¼Œå¤±è´¥æ—¶æ˜¾ç¤ºå‹å¥½æç¤º
      try {
        updateLoaderText('æ­£åœ¨åˆå§‹åŒ–...')

        // åŠ è½½Three.jsæ ¸å¿ƒåº“ï¼ˆå¿…éœ€ï¼‰- æ”¯æŒå¤šä¸ªå¤‡ç”¨CDNä¾æ¬¡å°è¯•
        THREE = await loadWithTimeout(
          import('three'),
          30000, // 30ç§’è¶…æ—¶ï¼ˆç§»åŠ¨ç«¯è‡ªåŠ¨æ”¹ä¸º5ç§’ï¼‰
          'Three.js',
          [
            () => import('three-unpkg'), // å¤‡ç”¨1: unpkg
            () => import('three-cdnjs'), // å¤‡ç”¨2: cdnjs
            () => import('three-bootcdn'), // å¤‡ç”¨3: bootcdnï¼ˆå›½å†…ï¼‰
          ],
        ).then((m) => m.default || m)

        updateLoaderText('æ­£åœ¨åŠ è½½æ’ä»¶...')

        // åŠ è½½Three.jsæ’ä»¶ - ç§»åŠ¨ç«¯ä¸²è¡ŒåŠ è½½æ›´ç¨³å®šï¼Œæ¡Œé¢ç«¯å¹¶è¡ŒåŠ è½½
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent,
        )

        let composerModule, renderPassModule, bloomModule, envModule

        // å¤‡ç”¨CDNåˆ—è¡¨
        const addonFallbacks = (path) => [
          () => import(`three-addons-unpkg/${path}`),
          () => import(`three-addons-cdnjs/${path}`),
          () => import(`three-addons-bootcdn/${path}`),
        ]

        if (isMobile) {
          // ç§»åŠ¨ç«¯ä¸²è¡ŒåŠ è½½ï¼Œæ›´ç¨³å®šï¼Œè¶…æ—¶æ—¶é—´5ç§’
          composerModule = await loadWithTimeout(
            import('three/addons/postprocessing/EffectComposer.js'),
            5000,
            'EffectComposer',
            addonFallbacks('postprocessing/EffectComposer.js'),
          )

          renderPassModule = await loadWithTimeout(
            import('three/addons/postprocessing/RenderPass.js'),
            5000,
            'RenderPass',
            addonFallbacks('postprocessing/RenderPass.js'),
          )

          bloomModule = await loadWithTimeout(
            import('three/addons/postprocessing/UnrealBloomPass.js'),
            5000,
            'UnrealBloomPass',
            addonFallbacks('postprocessing/UnrealBloomPass.js'),
          )

          envModule = await loadWithTimeout(
            import('three/addons/environments/RoomEnvironment.js'),
            5000,
            'RoomEnvironment',
            addonFallbacks('environments/RoomEnvironment.js'),
          )
        } else {
          // æ¡Œé¢ç«¯å¹¶è¡ŒåŠ è½½ï¼Œæ›´å¿«
          ;[composerModule, renderPassModule, bloomModule, envModule] = await Promise.all([
            loadWithTimeout(
              import('three/addons/postprocessing/EffectComposer.js'),
              25000,
              'EffectComposer',
              addonFallbacks('postprocessing/EffectComposer.js'),
            ),
            loadWithTimeout(
              import('three/addons/postprocessing/RenderPass.js'),
              25000,
              'RenderPass',
              addonFallbacks('postprocessing/RenderPass.js'),
            ),
            loadWithTimeout(
              import('three/addons/postprocessing/UnrealBloomPass.js'),
              25000,
              'UnrealBloomPass',
              addonFallbacks('postprocessing/UnrealBloomPass.js'),
            ),
            loadWithTimeout(
              import('three/addons/environments/RoomEnvironment.js'),
              25000,
              'RoomEnvironment',
              addonFallbacks('environments/RoomEnvironment.js'),
            ),
          ])
        }

        EffectComposer = composerModule.EffectComposer
        RenderPass = renderPassModule.RenderPass
        UnrealBloomPass = bloomModule.UnrealBloomPass
        RoomEnvironment = envModule.RoomEnvironment

        updateLoaderText('æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«...')

        // MediaPipeå¯é€‰åŠ è½½ï¼Œå¤±è´¥ä¸å½±å“ä¸»åŠŸèƒ½
        try {
          const mediapipe = await loadWithTimeout(
            import('@mediapipe/tasks-vision'),
            20000,
            'MediaPipe',
            [], // MediaPipeæ²¡æœ‰å¤‡ç”¨CDNï¼Œå¤±è´¥ç›´æ¥è·³è¿‡
          )
          FilesetResolver = mediapipe.FilesetResolver
          HandLandmarker = mediapipe.HandLandmarker
        } catch (e) {
          console.warn('MediaPipeåŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨æŒ‰é’®æ§åˆ¶:', e)
          FilesetResolver = null
          HandLandmarker = null
        }

        updateLoaderText('åŠ è½½å®Œæˆï¼')
      } catch (err) {
        console.error('å…³é”®èµ„æºåŠ è½½å¤±è´¥:', err)
        const loader = document.getElementById('loader')
        if (loader) {
          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent,
          )
          const errorMsg = isMobile
            ? 'ç½‘ç»œè¿æ¥è¾ƒæ…¢ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•'
            : err.message || 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'

          loader.innerHTML = `
                    <div style="color: #d4af37; text-align: center; padding: 20px;">
                        <div style="font-size: 18px; margin-bottom: 15px;">âš ï¸ èµ„æºåŠ è½½å¤±è´¥</div>
                        <div style="font-size: 12px; opacity: 0.8; margin-bottom: 15px; line-height: 1.6;">${errorMsg}</div>
                        <div style="font-size: 11px; opacity: 0.6; margin-bottom: 20px; padding: 10px; background: rgba(212, 175, 55, 0.1); border-radius: 4px;">
                            <div style="margin-bottom: 5px;">ğŸ’¡ è§£å†³æ–¹æ¡ˆï¼š</div>
                            <div style="text-align: left; padding-left: 10px;">
                                <div>1. æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼ˆå»ºè®®ä½¿ç”¨WiFiï¼‰</div>
                                <div>2. åˆ·æ–°é¡µé¢é‡è¯•</div>
                                <div>3. å¦‚æœæŒç»­å¤±è´¥ï¼Œè¯·è”ç³»ç®¡ç†å‘˜</div>
                            </div>
                        </div>
                        <button onclick="location.reload()" style="
                            background: rgba(212, 175, 55, 0.3);
                            border: 1px solid #d4af37;
                            color: #d4af37;
                            padding: 12px 24px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 14px;
                            margin-right: 10px;
                        ">åˆ·æ–°é¡µé¢</button>
                        <button onclick="document.getElementById('loader').style.display='none'; init().catch(e => console.error(e));" style="
                            background: rgba(212, 175, 55, 0.5);
                            border: 1px solid #d4af37;
                            color: #d4af37;
                            padding: 12px 24px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 14px;
                        ">è·³è¿‡åŠ è½½</button>
                    </div>
                `
        }
        // ä¸æŠ›å‡ºé”™è¯¯ï¼Œè®©é¡µé¢ç»§ç»­åŠ è½½ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
        console.warn('èµ„æºåŠ è½½å¤±è´¥ï¼Œä½†ç»§ç»­å°è¯•åˆå§‹åŒ–')
        // å³ä½¿èµ„æºåŠ è½½å¤±è´¥ï¼Œä¹Ÿå°è¯•åˆå§‹åŒ–ï¼ˆå¯èƒ½éƒ¨åˆ†åŠŸèƒ½ä¸å¯ç”¨ï¼‰
        if (!THREE) {
          console.error('Three.jsåŠ è½½å¤±è´¥ï¼Œæ— æ³•ç»§ç»­')
          // æ˜¾ç¤ºé”™è¯¯å¹¶åœæ­¢æ‰§è¡Œ
          const loader = document.getElementById('loader')
          if (loader) {
            loader.innerHTML = `
                        <div style="color: #d4af37; text-align: center; padding: 20px;">
                            <div style="font-size: 18px; margin-bottom: 15px;">âŒ æ— æ³•åŠ è½½</div>
                            <div style="font-size: 12px; opacity: 0.8; margin-bottom: 20px;">Three.jsæ ¸å¿ƒåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•</div>
                            <button onclick="location.reload()" style="
                                background: rgba(212, 175, 55, 0.3);
                                border: 1px solid #d4af37;
                                color: #d4af37;
                                padding: 12px 24px;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 14px;
                            ">åˆ·æ–°é¡µé¢</button>
                        </div>
                    `
          }
          // ä¸ç»§ç»­æ‰§è¡Œ
        }
      }

      // åˆå§‹åŒ–åº”ç”¨ï¼ˆå°è£…ä¸ºå‡½æ•°ï¼Œé¿å…é¡¶å±‚returnï¼‰
      function initializeApp() {
        if (!THREE) {
          console.error('Three.jsæœªåŠ è½½ï¼Œæ— æ³•åˆå§‹åŒ–')
          return
        }

        // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿DOMå·²åŠ è½½
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => init(), 100)
          })
        } else {
          setTimeout(() => init(), 100)
        }
      }

      // èµ„æºåŠ è½½å®Œæˆååˆå§‹åŒ–ï¼ˆæ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼‰
      if (THREE) {
        // Three.jsåŠ è½½æˆåŠŸï¼Œç»§ç»­åˆå§‹åŒ–
        initializeApp()
      } else {
        // Three.jsæœªåŠ è½½ï¼Œå·²åœ¨catchä¸­å¤„ç†
        console.warn('ç­‰å¾…Three.jsåŠ è½½...')
      }

      // --- é…ç½® ---
      const CONFIG = {
        // é¢œè‰²ä¸»é¢˜é…ç½®
        colorThemes: [
          {
            name: 'default',
            bg: 0x000000,
            champagneGold: 0xffd966,
            deepGreen: 0x03180a,
            accentRed: 0x990000,
            goldEmissive: 0x443300,
            greenEmissive: 0x002200,
            redEmissive: 0x330000,
          },
          {
            name: 'blue',
            bg: 0x000510,
            champagneGold: 0x88ccff,
            deepGreen: 0x001122,
            accentRed: 0x4488ff,
            goldEmissive: 0x224466,
            greenEmissive: 0x001133,
            redEmissive: 0x223366,
          },
          {
            name: 'pink',
            bg: 0x0a0005,
            champagneGold: 0xffaacc,
            deepGreen: 0x220011,
            accentRed: 0xff6699,
            goldEmissive: 0x662244,
            greenEmissive: 0x220011,
            redEmissive: 0x662244,
          },
        ],
        particles: {
          count: 2000,
          dustCount: 800,
          treeHeight: 20,
          treeRadius: 6.5,
        },
        camera: {
          z: 55,
        },
      }

      const STATE = {
        mode: 'TREE',
        focusTarget: null,
        hand: { detected: false, x: 0, y: 0 },
        rotation: { x: 0, y: 0 },
        touch: {
          isDragging: false,
          lastX: 0,
          lastY: 0,
          pinchDistance: 0,
        },
        hasCamera: false,
        cameraEnabled: false,
        gesture: {
          lastMode: 'TREE',
          lastModeTime: 0,
          debounceDelay: 300, // é˜²æŠ–å»¶è¿Ÿ300ms
          lastThumbUpTime: 0,
          thumbUpDebounceDelay: 500, // å¤§æ‹‡æŒ‡æ‰‹åŠ¿é˜²æŠ–å»¶è¿Ÿ500ms
        },
        colorThemeIndex: 0, // å½“å‰é¢œè‰²ä¸»é¢˜ç´¢å¼•
      }

      let scene, camera, renderer, composer
      let mainGroup
      let clock = new THREE.Clock()
      let particleSystem = []
      let photoMeshGroup = new THREE.Group()
      let handLandmarker, video
      let caneTexture
      // ä¿å­˜æè´¨å¼•ç”¨ï¼Œç”¨äºé¢œè‰²åˆ‡æ¢
      let materialRefs = {
        goldMat: null,
        greenMat: null,
        redMat: null,
        starMat: null,
      }

      async function init() {
        try {
          initThree()
          setupEnvironment()
          setupLights()
          createTextures()
          createParticles()
          createDust()
          createDefaultPhotos()
          setupPostProcessing()
          setupEvents()

          // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
          document.getElementById('btn-tree').classList.add('active')

          // å¯åŠ¨åŠ¨ç”»
          animate()

          // éšè—åŠ è½½å™¨ï¼Œç¡®ä¿ä¸€å®šä¼šéšè—
          hideLoader()
        } catch (err) {
          console.error('åˆå§‹åŒ–å¤±è´¥:', err)
          // å³ä½¿å‡ºé”™ä¹Ÿè¦éšè—åŠ è½½å™¨
          hideLoader()
          // æ˜¾ç¤ºé”™è¯¯æç¤º
          showError('é¡µé¢åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•')
        }

        // å¼‚æ­¥å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«ï¼Œä¸é˜»å¡é¡µé¢æ˜¾ç¤º
        initMediaPipe().catch((err) => {
          // é”™è¯¯å·²åœ¨ initMediaPipe å†…éƒ¨å¤„ç†ï¼Œè¿™é‡Œåªåšå…œåº•
          if (!err.message || !err.message.includes('timeout')) {
            console.log('Fallback to button controls')
          }
        })
      }

      // éšè—åŠ è½½å™¨
      function hideLoader() {
        const loader = document.getElementById('loader')
        if (loader) {
          loader.style.opacity = '0'
          setTimeout(() => {
            if (loader.parentNode) {
              loader.remove()
            }
          }, 800)
        }
      }

      // æ˜¾ç¤ºé”™è¯¯æç¤º
      function showError(message) {
        const errorDiv = document.createElement('div')
        errorDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 0, 0, 0.9);
                color: white;
                padding: 20px;
                border-radius: 8px;
                z-index: 1000;
                text-align: center;
                max-width: 80%;
            `
        errorDiv.textContent = message
        document.body.appendChild(errorDiv)
        setTimeout(() => errorDiv.remove(), 5000)
      }

      // æ·»åŠ èµ„æºåŠ è½½è¶…æ—¶ä¿æŠ¤
      window.addEventListener(
        'error',
        (e) => {
          console.error('èµ„æºåŠ è½½é”™è¯¯:', e)
          // å¦‚æœæ˜¯å…³é”®èµ„æºåŠ è½½å¤±è´¥ï¼Œéšè—åŠ è½½å™¨
          if (e.target && (e.target.tagName === 'SCRIPT' || e.target.tagName === 'LINK')) {
            hideLoader()
          }
        },
        true,
      )

      // æ·»åŠ æœªæ•è·çš„Promiseé”™è¯¯å¤„ç†
      window.addEventListener('unhandledrejection', (e) => {
        console.error('æœªå¤„ç†çš„Promiseé”™è¯¯:', e.reason)
        hideLoader()
      })

      function initThree() {
        const container = document.getElementById('canvas-container')
        scene = new THREE.Scene()
        const currentTheme = CONFIG.colorThemes[STATE.colorThemeIndex]
        scene.background = new THREE.Color(currentTheme.bg)
        scene.fog = new THREE.FogExp2(currentTheme.bg, 0.01)

        camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.set(0, 2, CONFIG.camera.z)

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: 'high-performance',
        })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        renderer.toneMapping = THREE.ReinhardToneMapping
        renderer.toneMappingExposure = 2.2
        container.appendChild(renderer.domElement)

        mainGroup = new THREE.Group()
        scene.add(mainGroup)
      }

      function setupEnvironment() {
        const pmremGenerator = new THREE.PMREMGenerator(renderer)
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture
      }

      function setupLights() {
        const ambient = new THREE.AmbientLight(0xffffff, 0.6)
        scene.add(ambient)

        const innerLight = new THREE.PointLight(0xffaa00, 2, 20)
        innerLight.position.set(0, 5, 0)
        mainGroup.add(innerLight)

        const spotGold = new THREE.SpotLight(0xffcc66, 1200)
        spotGold.position.set(30, 40, 40)
        spotGold.angle = 0.5
        spotGold.penumbra = 0.5
        scene.add(spotGold)

        const spotBlue = new THREE.SpotLight(0x6688ff, 600)
        spotBlue.position.set(-30, 20, -30)
        scene.add(spotBlue)

        const fill = new THREE.DirectionalLight(0xffeebb, 0.8)
        fill.position.set(0, 0, 50)
        scene.add(fill)
      }

      function setupPostProcessing() {
        const renderScene = new RenderPass(scene, camera)
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85,
        )
        bloomPass.threshold = 0.7
        bloomPass.strength = 0.45
        bloomPass.radius = 0.4

        composer = new EffectComposer(renderer)
        composer.addPass(renderScene)
        composer.addPass(bloomPass)
      }

      function createTextures() {
        const canvas = document.createElement('canvas')
        canvas.width = 128
        canvas.height = 128
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = '#ffffff'
        ctx.fillRect(0, 0, 128, 128)
        ctx.fillStyle = '#880000'
        ctx.beginPath()
        for (let i = -128; i < 256; i += 32) {
          ctx.moveTo(i, 0)
          ctx.lineTo(i + 32, 128)
          ctx.lineTo(i + 16, 128)
          ctx.lineTo(i - 16, 0)
        }
        ctx.fill()
        caneTexture = new THREE.CanvasTexture(canvas)
        caneTexture.wrapS = THREE.RepeatWrapping
        caneTexture.wrapT = THREE.RepeatWrapping
        caneTexture.repeat.set(3, 3)
      }

      class Particle {
        constructor(mesh, type, isDust = false) {
          this.mesh = mesh
          this.type = type
          this.isDust = isDust

          this.posTree = new THREE.Vector3()
          this.posScatter = new THREE.Vector3()
          this.baseScale = mesh.scale.x

          const speedMult = type === 'PHOTO' ? 0.3 : 2.0
          this.spinSpeed = new THREE.Vector3(
            (Math.random() - 0.5) * speedMult,
            (Math.random() - 0.5) * speedMult,
            (Math.random() - 0.5) * speedMult,
          )

          this.calculatePositions()
        }

        calculatePositions() {
          const h = CONFIG.particles.treeHeight
          const halfH = h / 2
          let t = Math.random()
          t = Math.pow(t, 0.8)
          const y = t * h - halfH
          let rMax = CONFIG.particles.treeRadius * (1.0 - t)
          if (rMax < 0.5) rMax = 0.5
          const angle = t * 50 * Math.PI + Math.random() * Math.PI
          const r = rMax * (0.8 + Math.random() * 0.4)
          this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r)

          let rScatter = this.isDust ? 12 + Math.random() * 20 : 8 + Math.random() * 12
          const theta = Math.random() * Math.PI * 2
          const phi = Math.acos(2 * Math.random() - 1)
          this.posScatter.set(
            rScatter * Math.sin(phi) * Math.cos(theta),
            rScatter * Math.sin(phi) * Math.sin(theta),
            rScatter * Math.cos(phi),
          )
        }

        update(dt, mode, focusTargetMesh) {
          let target = this.posTree

          if (mode === 'SCATTER') target = this.posScatter
          else if (mode === 'FOCUS') {
            if (this.mesh === focusTargetMesh) {
              // è°ƒæ•´èšç„¦ä½ç½®ï¼Œç¨å¾®è¿œç¦»ç›¸æœºï¼Œé¿å…è¿‡äº®
              const desiredWorldPos = new THREE.Vector3(0, 2, 40)
              const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert()
              target = desiredWorldPos.applyMatrix4(invMatrix)
            } else {
              target = this.posScatter
            }
          }

          const lerpSpeed = mode === 'FOCUS' && this.mesh === focusTargetMesh ? 5.0 : 2.0
          this.mesh.position.lerp(target, lerpSpeed * dt)

          if (mode === 'SCATTER') {
            this.mesh.rotation.x += this.spinSpeed.x * dt
            this.mesh.rotation.y += this.spinSpeed.y * dt
            this.mesh.rotation.z += this.spinSpeed.z * dt
          } else if (mode === 'TREE') {
            this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt)
            this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt)
            this.mesh.rotation.y += 0.5 * dt
          }

          if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
            this.mesh.lookAt(camera.position)
          }

          let s = this.baseScale
          if (this.isDust) {
            s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id))
            if (mode === 'TREE') s = 0
          } else if (mode === 'SCATTER' && this.type === 'PHOTO') {
            s = this.baseScale * 2.5
          } else if (mode === 'FOCUS') {
            if (this.mesh === focusTargetMesh) s = 4.5
            else s = this.baseScale * 0.8
          }

          this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 4 * dt)
        }
      }

      function createParticles() {
        const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32)
        const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55)
        const curve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0, -0.5, 0),
          new THREE.Vector3(0, 0.3, 0),
          new THREE.Vector3(0.1, 0.5, 0),
          new THREE.Vector3(0.3, 0.4, 0),
        ])
        const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false)

        const theme = CONFIG.colorThemes[STATE.colorThemeIndex]

        const goldMat = new THREE.MeshStandardMaterial({
          color: theme.champagneGold,
          metalness: 1.0,
          roughness: 0.1,
          envMapIntensity: 2.0,
          emissive: theme.goldEmissive,
          emissiveIntensity: 0.3,
        })

        const greenMat = new THREE.MeshStandardMaterial({
          color: theme.deepGreen,
          metalness: 0.2,
          roughness: 0.8,
          emissive: theme.greenEmissive,
          emissiveIntensity: 0.2,
        })

        const redMat = new THREE.MeshPhysicalMaterial({
          color: theme.accentRed,
          metalness: 0.3,
          roughness: 0.2,
          clearcoat: 1.0,
          emissive: theme.redEmissive,
        })

        const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 })

        // ä¿å­˜æè´¨å¼•ç”¨
        materialRefs.goldMat = goldMat
        materialRefs.greenMat = greenMat
        materialRefs.redMat = redMat

        for (let i = 0; i < CONFIG.particles.count; i++) {
          const rand = Math.random()
          let mesh, type

          if (rand < 0.4) {
            mesh = new THREE.Mesh(boxGeo, greenMat)
            type = 'BOX'
          } else if (rand < 0.7) {
            mesh = new THREE.Mesh(boxGeo, goldMat)
            type = 'GOLD_BOX'
          } else if (rand < 0.82) {
            mesh = new THREE.Mesh(sphereGeo, goldMat)
            type = 'GOLD_SPHERE'
          } else if (rand < 0.95) {
            mesh = new THREE.Mesh(sphereGeo, redMat)
            type = 'RED'
          } else {
            mesh = new THREE.Mesh(candyGeo, candyMat)
            type = 'CANE'
          }

          const s = 0.25 + Math.random() * 0.25
          mesh.scale.set(s, s, s)
          mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6)

          mainGroup.add(mesh)
          particleSystem.push(new Particle(mesh, type, false))
        }

        // åˆ›å»ºäº”è§’æ˜Ÿå‡ ä½•ä½“
        function createStarGeometry(outerRadius, innerRadius, depth) {
          const shape = new THREE.Shape()
          const points = 5
          const angleStep = (Math.PI * 2) / points

          for (let i = 0; i < points * 2; i++) {
            const angle = (i * angleStep) / 2 + Math.PI / 2
            const radius = i % 2 === 0 ? outerRadius : innerRadius
            const x = Math.cos(angle) * radius
            const y = Math.sin(angle) * radius

            if (i === 0) {
              shape.moveTo(x, y)
            } else {
              shape.lineTo(x, y)
            }
          }
          shape.closePath()

          const extrudeSettings = {
            depth: depth,
            bevelEnabled: true,
            bevelThickness: 0.05,
            bevelSize: 0.05,
            bevelSegments: 3,
          }

          return new THREE.ExtrudeGeometry(shape, extrudeSettings)
        }

        const starGeo = createStarGeometry(1.2, 0.5, 0.3)
        const starTheme = CONFIG.colorThemes[STATE.colorThemeIndex]
        const starMat = new THREE.MeshStandardMaterial({
          color: starTheme.champagneGold,
          emissive: starTheme.champagneGold,
          emissiveIntensity: 1.0,
          metalness: 1.0,
          roughness: 0,
        })
        materialRefs.starMat = starMat
        const star = new THREE.Mesh(starGeo, starMat)
        star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0)
        mainGroup.add(star)

        mainGroup.add(photoMeshGroup)
      }

      function createDust() {
        const geo = new THREE.TetrahedronGeometry(0.08, 0)
        const mat = new THREE.MeshBasicMaterial({
          color: 0xffeebb,
          transparent: true,
          opacity: 0.8,
        })

        for (let i = 0; i < CONFIG.particles.dustCount; i++) {
          const mesh = new THREE.Mesh(geo, mat)
          mesh.scale.setScalar(0.5 + Math.random())
          mainGroup.add(mesh)
          particleSystem.push(new Particle(mesh, 'DUST', true))
        }
      }

      function createDefaultPhotos() {
        const canvas = document.createElement('canvas')
        canvas.width = 512
        canvas.height = 512
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = '#050505'
        ctx.fillRect(0, 0, 512, 512)
        ctx.strokeStyle = '#eebb66'
        ctx.lineWidth = 15
        ctx.strokeRect(20, 20, 472, 472)
        ctx.font = '500 60px Times New Roman'
        ctx.fillStyle = '#eebb66'
        ctx.textAlign = 'center'
        ctx.fillText('JOYEUX', 256, 230)
        ctx.fillText('NOEL', 256, 300)

        const tex = new THREE.CanvasTexture(canvas)
        tex.colorSpace = THREE.SRGBColorSpace
        addPhotoToScene(tex)
      }

      function addPhotoToScene(texture) {
        const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05)
        const currentTheme = CONFIG.colorThemes[STATE.colorThemeIndex]
        const frameMat = new THREE.MeshStandardMaterial({
          color: currentTheme.champagneGold,
          metalness: 1.0,
          roughness: 0.1,
        })
        const frame = new THREE.Mesh(frameGeo, frameMat)

        const photoGeo = new THREE.PlaneGeometry(1.2, 1.2)
        // ä½¿ç”¨ MeshBasicMaterialï¼Œä¸å—å…‰ç…§å½±å“ï¼Œç›´æ¥æ˜¾ç¤ºå›¾ç‰‡åŸå§‹é¢œè‰²
        // é€šè¿‡è°ƒæ•´é¢œè‰²æ¥é™ä½æ•´ä½“äº®åº¦
        const photoMat = new THREE.MeshBasicMaterial({
          map: texture,
          toneMapped: false, // ç¦ç”¨è‰²è°ƒæ˜ å°„ï¼Œä¿æŒåŸå§‹é¢œè‰²
          color: 0xaaaaaa, // ç¨å¾®é™ä½æ•´ä½“äº®åº¦ï¼ˆ0xaaaaaa çº¦ä¸º 67% äº®åº¦ï¼‰
        })
        const photo = new THREE.Mesh(photoGeo, photoMat)
        photo.position.z = 0.04

        const group = new THREE.Group()
        group.add(frame)
        group.add(photo)

        const s = 0.8
        group.scale.set(s, s, s)

        photoMeshGroup.add(group)
        particleSystem.push(new Particle(group, 'PHOTO', false))
      }

      function handleImageUpload(e) {
        const files = e.target.files
        if (!files.length) return
        Array.from(files).forEach((f) => {
          const reader = new FileReader()
          reader.onload = (ev) => {
            new THREE.TextureLoader().load(ev.target.result, (t) => {
              t.colorSpace = THREE.SRGBColorSpace
              addPhotoToScene(t)
            })
          }
          reader.readAsDataURL(f)
        })
      }

      // æ£€æµ‹æ˜¯å¦æœ‰æ‘„åƒå¤´
      async function checkCameraAvailability() {
        try {
          if (!navigator.mediaDevices?.getUserMedia) {
            console.log('getUserMedia not supported')
            return false
          }
          // å…ˆå°è¯•è·å–è®¾å¤‡åˆ—è¡¨ï¼ˆéœ€è¦æƒé™ï¼‰
          try {
            const devices = await navigator.mediaDevices.enumerateDevices()
            const hasVideoInput = devices.some((device) => device.kind === 'videoinput')
            if (hasVideoInput) {
              return true
            }
          } catch (e) {
            // å¦‚æœæ²¡æœ‰æƒé™ï¼Œå°è¯•ç›´æ¥è¯·æ±‚æ‘„åƒå¤´
            console.log('Cannot enumerate devices, trying direct access')
          }
          // å°è¯•ç›´æ¥è¯·æ±‚æ‘„åƒå¤´ï¼ˆç§»åŠ¨ç«¯å¯èƒ½éœ€è¦ï¼‰
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true })
            stream.getTracks().forEach((track) => track.stop()) // ç«‹å³åœæ­¢ï¼Œåªæ˜¯æ£€æµ‹
            return true
          } catch (e) {
            console.log('Camera access failed:', e.name)
            return false
          }
        } catch (err) {
          console.warn('Camera check failed:', err)
          return false
        }
      }

      // --- MEDIAPIPE æ‰‹åŠ¿è¯†åˆ« ---
      async function initMediaPipe() {
        try {
          video = document.getElementById('webcam')

          // å…ˆæ£€æµ‹æ˜¯å¦æœ‰æ‘„åƒå¤´
          console.log('Checking camera availability...')
          STATE.hasCamera = await checkCameraAvailability()
          console.log('Camera available:', STATE.hasCamera)

          if (!STATE.hasCamera) {
            console.log('No camera available, using button controls')
            showButtonControls()
            if (video) {
              video.style.display = 'none'
            }
            return
          }

          // å…ˆè¯·æ±‚æ‘„åƒå¤´æƒé™ï¼ˆåœ¨ MediaPipe ä¹‹å‰ï¼‰
          const constraints = {
            video: {
              facingMode: 'user',
              width: { ideal: 320 },
              height: { ideal: 240 },
              aspectRatio: { ideal: 4 / 3 },
            },
          }

          let stream
          try {
            stream = await navigator.mediaDevices.getUserMedia(constraints)
            video.srcObject = stream
            STATE.cameraEnabled = true
            console.log('Camera access granted')
          } catch (permissionErr) {
            console.warn('Camera permission denied:', permissionErr)
            STATE.cameraEnabled = false
            showButtonControls()
            if (video) {
              video.style.display = 'none'
            }
            return
          }

          // æ·»åŠ è¶…æ—¶å¤„ç†ï¼ˆç¼©çŸ­è¶…æ—¶æ—¶é—´ï¼Œæ›´å¿«å›é€€ï¼‰
          const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('MediaPipe initialization timeout')), 8000),
          )

          console.log('Initializing MediaPipe...')
          const visionPromise = FilesetResolver.forVisionTasks(
            'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm',
          )

          const vision = await Promise.race([visionPromise, timeoutPromise])

          const handLandmarkerPromise = HandLandmarker.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
              delegate: 'GPU',
            },
            runningMode: 'VIDEO',
            numHands: 1,
          })

          handLandmarker = await Promise.race([handLandmarkerPromise, timeoutPromise])
          console.log('MediaPipe initialized successfully')

          // ç¡®ä¿è§†é¢‘å·²åŠ è½½åå†å¯åŠ¨é¢„æµ‹
          if (video.readyState >= 2) {
            console.log('Video already loaded, starting gesture recognition')
            predictWebcam()
          } else {
            video.addEventListener(
              'loadeddata',
              () => {
                console.log('Video loaded, starting gesture recognition')
                predictWebcam()
              },
              { once: true },
            )
          }

          // éšè—æŒ‰é’®æ§åˆ¶ï¼Œä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶
          hideButtonControls()
          console.log('æ‰‹åŠ¿è¯†åˆ«å·²å¯ç”¨ï¼ŒæŒ‰é’®æ§åˆ¶å·²éšè—')
        } catch (err) {
          // é™é»˜å¤„ç†è¶…æ—¶é”™è¯¯ï¼Œç›´æ¥åˆ‡æ¢åˆ°æŒ‰é’®æ§åˆ¶
          if (err.message && err.message.includes('timeout')) {
            console.log('MediaPipe initialization timeout, using button controls')
          } else {
            console.warn('MediaPipe initialization failed:', err)
          }
          STATE.cameraEnabled = false
          showButtonControls()
          // éšè—æ‘„åƒå¤´é¢„è§ˆï¼Œå¦‚æœåˆå§‹åŒ–å¤±è´¥
          if (video) {
            video.style.display = 'none'
          }
          // åœæ­¢æ‘„åƒå¤´æµ
          if (video && video.srcObject) {
            const stream = video.srcObject
            stream.getTracks().forEach((track) => track.stop())
            video.srcObject = null
          }
        }
      }

      // æ˜¾ç¤ºæŒ‰é’®æ§åˆ¶
      function showButtonControls() {
        const controlButtons = document.getElementById('control-buttons')
        const hintText = document.getElementById('hint-text')
        if (controlButtons) {
          controlButtons.style.display = 'flex'
        }
        if (hintText) {
          hintText.textContent = 'ç‚¹å‡»æŒ‰é’®åˆ‡æ¢æ¨¡å¼'
        }
      }

      // éšè—æŒ‰é’®æ§åˆ¶
      function hideButtonControls() {
        const controlButtons = document.getElementById('control-buttons')
        const hintText = document.getElementById('hint-text')
        if (controlButtons) {
          controlButtons.style.display = 'none'
        }
        if (hintText) {
          hintText.textContent = 'ğŸ–ï¸ å¼ å¼€æ•£å¼€ Â· âœŠ æ¡æ‹³åˆæ‹¢ Â· ğŸ¤ æåˆèšç„¦ Â· ğŸ‘ åˆ‡æ¢é¢œè‰²'
        }
      }

      // æŒ‰é’®æ§åˆ¶æ¨¡å¼åˆ‡æ¢
      function setModeFromButton(mode) {
        STATE.mode = mode
        STATE.focusTarget = null

        if (mode === 'FOCUS') {
          const photos = particleSystem.filter((p) => p.type === 'PHOTO')
          if (photos.length) {
            STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh
          } else {
            // å¦‚æœæ²¡æœ‰ç…§ç‰‡ï¼Œåˆ‡æ¢åˆ°æ ‘å½¢
            STATE.mode = 'TREE'
          }
        }

        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        document.querySelectorAll('.control-btn').forEach((btn) => {
          btn.classList.remove('active')
          if (btn.dataset.mode === mode) {
            btn.classList.add('active')
          }
        })
      }

      let lastVideoTime = -1
      async function predictWebcam() {
        // æ£€æŸ¥è§†é¢‘æ˜¯å¦å·²åŠ è½½ä¸”æ‘„åƒå¤´å·²å¯ç”¨
        if (!video || !video.readyState || video.readyState < 2 || !STATE.cameraEnabled) {
          requestAnimationFrame(predictWebcam)
          return
        }

        if (video.currentTime !== lastVideoTime) {
          lastVideoTime = video.currentTime
          if (handLandmarker && STATE.cameraEnabled) {
            try {
              const result = handLandmarker.detectForVideo(video, performance.now())
              processGestures(result)
            } catch (err) {
              console.warn('æ‰‹åŠ¿è¯†åˆ«é”™è¯¯:', err)
            }
          }
        }
        requestAnimationFrame(predictWebcam)
      }

      // æ£€æµ‹å•æ ¹æ‰‹æŒ‡æ˜¯å¦å¼¯æ›²ï¼ˆä½¿ç”¨å¤šä¸ªå…³èŠ‚ç‚¹åˆ¤æ–­ï¼‰
      function isFingerCurled(lm, tipIdx, pipIdx, mcpIdx) {
        const tip = lm[tipIdx]
        const pip = lm[pipIdx]
        const mcp = lm[mcpIdx]
        const wrist = lm[0]

        // æ–¹æ³•1ï¼šæŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦» vs æŒ‡æ ¹åˆ°æ‰‹è…•çš„è·ç¦»
        const tipToWrist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y, tip.z - wrist.z)
        const mcpToWrist = Math.hypot(mcp.x - wrist.x, mcp.y - wrist.y, mcp.z - wrist.z)

        // æ–¹æ³•2ï¼šæ£€æŸ¥Yè½´ï¼ˆåœ¨æ­£å¸¸æ‰‹åŠ¿ä¸‹ï¼Œå¼¯æ›²çš„æ‰‹æŒ‡tip.y > pip.yï¼‰
        // è¿™é‡Œç”¨ç›¸å¯¹æ¯”è¾ƒï¼Œæ›´é²æ£’
        const tipBelowPip = tip.y > pip.y + 0.02 // æŒ‡å°–åœ¨PIPå…³èŠ‚ä¸‹æ–¹

        // ç»¼åˆåˆ¤æ–­ï¼šæŒ‡å°–æ¯”æŒ‡æ ¹æ›´æ¥è¿‘æ‰‹è…•ï¼Œæˆ–è€…æŒ‡å°–åœ¨PIPä¸‹æ–¹
        return tipToWrist < mcpToWrist * 0.85 || tipBelowPip
      }

      // æ£€æµ‹æ‹‡æŒ‡æ˜¯å¦å¼¯æ›²ï¼ˆæ‹‡æŒ‡ç»“æ„ä¸åŒï¼Œå•ç‹¬å¤„ç†ï¼‰
      function isThumbCurled(lm) {
        const thumbTip = lm[4]
        const thumbIp = lm[3]
        const thumbMcp = lm[2]
        const indexMcp = lm[5]

        // æ‹‡æŒ‡å°–åˆ°é£ŸæŒ‡æ ¹éƒ¨çš„è·ç¦»ï¼ˆå¼¯æ›²æ—¶ä¼šé è¿‘ï¼‰
        const thumbToIndex = Math.hypot(thumbTip.x - indexMcp.x, thumbTip.y - indexMcp.y)

        // æ‹‡æŒ‡å°–åˆ°æ‹‡æŒ‡æ ¹çš„è·ç¦»
        const thumbLength = Math.hypot(thumbTip.x - thumbMcp.x, thumbTip.y - thumbMcp.y)

        return thumbToIndex < 0.1 || thumbLength < 0.08
      }

      // æ£€æµ‹å¤§æ‹‡æŒ‡æ˜¯å¦ä¼¸å‡ºï¼ˆç‚¹èµæ‰‹åŠ¿ï¼‰
      function isThumbUp(lm) {
        const thumbTip = lm[4]
        const thumbIp = lm[3]
        const thumbMcp = lm[2]
        const indexMcp = lm[5]

        // æ‹‡æŒ‡å°–åˆ°é£ŸæŒ‡æ ¹éƒ¨çš„è·ç¦»ï¼ˆä¼¸å‡ºæ—¶åº”è¯¥è¾ƒè¿œï¼‰
        const thumbToIndex = Math.hypot(thumbTip.x - indexMcp.x, thumbTip.y - indexMcp.y)

        // æ‹‡æŒ‡å°–åˆ°æ‹‡æŒ‡æ ¹çš„è·ç¦»
        const thumbLength = Math.hypot(thumbTip.x - thumbMcp.x, thumbTip.y - thumbMcp.y)

        // æ‹‡æŒ‡å‘ä¸Šï¼šæ‹‡æŒ‡å°–åœ¨æ‹‡æŒ‡æ ¹ä¸Šæ–¹ï¼Œä¸”è·ç¦»é£ŸæŒ‡æ ¹éƒ¨è¾ƒè¿œ
        const thumbUpward = thumbTip.y < thumbMcp.y // æ‹‡æŒ‡å°–åœ¨æ‹‡æŒ‡æ ¹ä¸Šæ–¹
        const thumbExtended = thumbLength > 0.12 // æ‹‡æŒ‡ä¼¸ç›´
        const thumbAwayFromIndex = thumbToIndex > 0.15 // æ‹‡æŒ‡è¿œç¦»é£ŸæŒ‡

        // å…¶ä»–æ‰‹æŒ‡åº”è¯¥å¼¯æ›²ï¼ˆæ¡æ‹³çŠ¶æ€ï¼‰
        const indexCurled = isFingerCurled(lm, 8, 6, 5)
        const middleCurled = isFingerCurled(lm, 12, 10, 9)
        const ringCurled = isFingerCurled(lm, 16, 14, 13)
        const pinkyCurled = isFingerCurled(lm, 20, 18, 17)
        const otherFingersCurled =
          [indexCurled, middleCurled, ringCurled, pinkyCurled].filter(Boolean).length >= 3

        return thumbUpward && thumbExtended && thumbAwayFromIndex && otherFingersCurled
      }

      function processGestures(result) {
        // åªæœ‰åœ¨æ‘„åƒå¤´å¯ç”¨ä¸”æ‰‹åŠ¿è¯†åˆ«å¯ç”¨æ—¶æ‰å¤„ç†æ‰‹åŠ¿
        if (!STATE.cameraEnabled || !handLandmarker) {
          return
        }

        if (result.landmarks && result.landmarks.length > 0) {
          STATE.hand.detected = true
          const lm = result.landmarks[0]
          STATE.hand.x = (lm[9].x - 0.5) * 2
          STATE.hand.y = (lm[9].y - 0.5) * 2

          // æ£€æµ‹æ¯æ ¹æ‰‹æŒ‡æ˜¯å¦å¼¯æ›²
          const indexCurled = isFingerCurled(lm, 8, 6, 5) // é£ŸæŒ‡
          const middleCurled = isFingerCurled(lm, 12, 10, 9) // ä¸­æŒ‡
          const ringCurled = isFingerCurled(lm, 16, 14, 13) // æ— åæŒ‡
          const pinkyCurled = isFingerCurled(lm, 20, 18, 17) // å°æŒ‡
          const thumbCurled = isThumbCurled(lm)

          // è®¡ç®—å¼¯æ›²æ‰‹æŒ‡æ•°é‡
          const curledCount = [indexCurled, middleCurled, ringCurled, pinkyCurled].filter(
            Boolean,
          ).length

          // æåˆæ£€æµ‹ï¼šæ‹‡æŒ‡å’Œé£ŸæŒ‡é è¿‘
          const thumbTip = lm[4]
          const indexTip = lm[8]
          const pinchDist = Math.hypot(
            thumbTip.x - indexTip.x,
            thumbTip.y - indexTip.y,
            thumbTip.z - indexTip.z,
          )
          const isPinching = pinchDist < 0.08 // æ”¾å®½é˜ˆå€¼

          // æ£€æµ‹OKæ‰‹åŠ¿ï¼šæ‹‡æŒ‡+é£ŸæŒ‡é è¿‘å½¢æˆåœ†åœˆï¼Œå…¶ä»–ä¸‰æŒ‡ä¼¸ç›´
          const otherFingersStraight = !middleCurled && !ringCurled && !pinkyCurled
          const isOkGesture = isPinching && otherFingersStraight

          // æ£€æµ‹å¤§æ‹‡æŒ‡ä¼¸å‡ºï¼ˆç‚¹èµæ‰‹åŠ¿ï¼‰
          const isThumbUpGesture = isThumbUp(lm)

          // å¤„ç†é¢œè‰²ä¸»é¢˜åˆ‡æ¢ï¼ˆå¤§æ‹‡æŒ‡æ‰‹åŠ¿ï¼‰
          if (isThumbUpGesture) {
            const now = Date.now()
            if (now - STATE.gesture.lastThumbUpTime >= STATE.gesture.thumbUpDebounceDelay) {
              STATE.gesture.lastThumbUpTime = now
              switchColorTheme()
            }
          }

          // æ‰‹åŠ¿åˆ¤æ–­é€»è¾‘ï¼ˆæ‰‹åŠ¿æ§åˆ¶ä¼˜å…ˆäºæŒ‰é’®æ§åˆ¶ï¼‰
          // 1. OKæ‰‹åŠ¿ï¼ˆğŸ‘Œï¼‰ï¼šæ‹‡æŒ‡é£ŸæŒ‡å½¢æˆåœ†åœˆï¼Œå…¶ä»–æ‰‹æŒ‡ä¼¸ç›´ â†’ èšç„¦
          // 2. æ¡æ‹³ï¼ˆâœŠï¼‰ï¼š3æ ¹ä»¥ä¸Šæ‰‹æŒ‡å¼¯æ›² â†’ æ ‘å½¢
          // 3. å¼ å¼€ï¼ˆğŸ–ï¸ï¼‰ï¼š2æ ¹ä»¥ä¸‹æ‰‹æŒ‡å¼¯æ›² â†’ æ•£å¼€
          // 4. å¤§æ‹‡æŒ‡ï¼ˆğŸ‘ï¼‰ï¼šä¼¸å‡ºå¤§æ‹‡æŒ‡ â†’ åˆ‡æ¢é¢œè‰²ä¸»é¢˜

          // æ£€æµ‹ç›®æ ‡æ¨¡å¼
          let targetMode = STATE.mode // é»˜è®¤ä¿æŒå½“å‰æ¨¡å¼

          if (isOkGesture) {
            targetMode = 'FOCUS'
          } else if (curledCount >= 3) {
            targetMode = 'TREE'
          } else if (curledCount <= 1 && !isPinching) {
            targetMode = 'SCATTER'
          }

          // é˜²æŠ–å¤„ç†ï¼šåªæœ‰ç›®æ ‡æ¨¡å¼ä¸å½“å‰æ¨¡å¼ä¸åŒï¼Œä¸”æŒç»­ä¸€å®šæ—¶é—´åæ‰åˆ‡æ¢
          const now = Date.now()

          if (targetMode !== STATE.gesture.lastMode) {
            // æ‰‹åŠ¿å˜åŒ–ï¼Œé‡ç½®è®¡æ—¶å™¨
            STATE.gesture.lastMode = targetMode
            STATE.gesture.lastModeTime = now
          } else if (targetMode !== STATE.mode) {
            // ç›®æ ‡æ¨¡å¼å·²ç¨³å®šï¼Œæ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜²æŠ–å»¶è¿Ÿ
            if (now - STATE.gesture.lastModeTime >= STATE.gesture.debounceDelay) {
              // æ‰§è¡Œæ¨¡å¼åˆ‡æ¢
              STATE.mode = targetMode

              if (targetMode === 'FOCUS') {
                // OKæ‰‹åŠ¿ â†’ èšç„¦ç…§ç‰‡
                const photos = particleSystem.filter((p) => p.type === 'PHOTO')
                if (photos.length) {
                  STATE.focusTarget = photos[Math.floor(Math.random() * photos.length)].mesh
                } else {
                  // å¦‚æœæ²¡æœ‰ç…§ç‰‡ï¼Œåˆ‡æ¢åˆ°æ ‘å½¢
                  STATE.mode = 'TREE'
                  STATE.focusTarget = null
                }
              } else {
                STATE.focusTarget = null
              }

              // æ›´æ–°æŒ‰é’®çŠ¶æ€
              updateButtonStates()
            }
          }
          // å¦‚æœç›®æ ‡æ¨¡å¼ä¸å½“å‰æ¨¡å¼ç›¸åŒï¼Œä¸éœ€è¦å¤„ç†
        } else {
          // æœªæ£€æµ‹åˆ°æ‰‹åŠ¿æ—¶ï¼Œå¦‚æœä¹‹å‰æ˜¯æ‰‹åŠ¿æ§åˆ¶ï¼Œä¿æŒå½“å‰æ¨¡å¼
          // ä¸å¼ºåˆ¶åˆ‡æ¢ï¼Œè®©ç”¨æˆ·ç»§ç»­çœ‹åˆ°å½“å‰çŠ¶æ€
          STATE.hand.detected = false
          // é‡ç½®é˜²æŠ–çŠ¶æ€
          STATE.gesture.lastMode = STATE.mode
          STATE.gesture.lastModeTime = Date.now()
        }
      }

      // æ›´æ–°æŒ‰é’®çŠ¶æ€ï¼ˆåŒæ­¥æ‰‹åŠ¿æ§åˆ¶çš„çŠ¶æ€ï¼‰
      function updateButtonStates() {
        document.querySelectorAll('.control-btn').forEach((btn) => {
          btn.classList.remove('active')
          if (btn.dataset.mode === STATE.mode) {
            btn.classList.add('active')
          }
        })
      }

      // åˆ‡æ¢é¢œè‰²ä¸»é¢˜
      function switchColorTheme() {
        STATE.colorThemeIndex = (STATE.colorThemeIndex + 1) % CONFIG.colorThemes.length
        const currentTheme = CONFIG.colorThemes[STATE.colorThemeIndex]

        // æ›´æ–°èƒŒæ™¯è‰²å’Œé›¾æ•ˆ
        scene.background = new THREE.Color(currentTheme.bg)
        scene.fog = new THREE.FogExp2(currentTheme.bg, 0.01)

        // æ›´æ–°æè´¨é¢œè‰²
        if (materialRefs.goldMat) {
          materialRefs.goldMat.color.setHex(currentTheme.champagneGold)
          materialRefs.goldMat.emissive.setHex(currentTheme.goldEmissive)
        }
        if (materialRefs.greenMat) {
          materialRefs.greenMat.color.setHex(currentTheme.deepGreen)
          materialRefs.greenMat.emissive.setHex(currentTheme.greenEmissive)
        }
        if (materialRefs.redMat) {
          materialRefs.redMat.color.setHex(currentTheme.accentRed)
          materialRefs.redMat.emissive.setHex(currentTheme.redEmissive)
        }
        if (materialRefs.starMat) {
          materialRefs.starMat.color.setHex(currentTheme.champagneGold)
          materialRefs.starMat.emissive.setHex(currentTheme.champagneGold)
        }

        console.log(`é¢œè‰²ä¸»é¢˜å·²åˆ‡æ¢ä¸º: ${currentTheme.name}`)
      }

      function setupEvents() {
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight
          camera.updateProjectionMatrix()
          renderer.setSize(window.innerWidth, window.innerHeight)
          composer.setSize(window.innerWidth, window.innerHeight)
        })

        document.getElementById('file-input').addEventListener('change', handleImageUpload)

        // æŒ‰é’®æ§åˆ¶äº‹ä»¶
        document.querySelectorAll('.control-btn').forEach((btn) => {
          btn.addEventListener('click', (e) => {
            const mode = e.target.dataset.mode
            if (mode) {
              setModeFromButton(mode)
            }
          })
        })

        // è§¦æ‘¸æ—‹è½¬
        const canvas = renderer.domElement

        canvas.addEventListener(
          'touchstart',
          (e) => {
            if (e.touches.length === 1) {
              STATE.touch.isDragging = true
              STATE.touch.lastX = e.touches[0].clientX
              STATE.touch.lastY = e.touches[0].clientY
            } else if (e.touches.length === 2) {
              STATE.touch.pinchDistance = getPinchDistance(e.touches)
            }
          },
          { passive: true },
        )

        canvas.addEventListener(
          'touchmove',
          (e) => {
            if (e.touches.length === 1 && STATE.touch.isDragging) {
              const deltaX = e.touches[0].clientX - STATE.touch.lastX
              const deltaY = e.touches[0].clientY - STATE.touch.lastY

              STATE.rotation.y += deltaX * 0.008
              STATE.rotation.x += deltaY * 0.004
              STATE.rotation.x = Math.max(-0.5, Math.min(0.5, STATE.rotation.x))

              STATE.touch.lastX = e.touches[0].clientX
              STATE.touch.lastY = e.touches[0].clientY
            } else if (e.touches.length === 2) {
              const newDistance = getPinchDistance(e.touches)
              const scale = newDistance / STATE.touch.pinchDistance
              camera.position.z = Math.max(25, Math.min(80, camera.position.z / scale))
              STATE.touch.pinchDistance = newDistance
            }
          },
          { passive: true },
        )

        canvas.addEventListener(
          'touchend',
          () => {
            STATE.touch.isDragging = false
          },
          { passive: true },
        )
      }

      function getPinchDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX
        const dy = touches[0].clientY - touches[1].clientY
        return Math.sqrt(dx * dx + dy * dy)
      }

      function animate() {
        requestAnimationFrame(animate)
        const dt = clock.getDelta()

        const autoRotate = !STATE.touch.isDragging

        // æ‰‹åŠ¿æ§åˆ¶æ—‹è½¬
        if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
          const targetRotY = STATE.hand.x * Math.PI * 0.9
          const targetRotX = STATE.hand.y * Math.PI * 0.25
          STATE.rotation.y += (targetRotY - STATE.rotation.y) * 3.0 * dt
          STATE.rotation.x += (targetRotX - STATE.rotation.x) * 3.0 * dt
        } else if (autoRotate) {
          if (STATE.mode === 'TREE') {
            STATE.rotation.y += 0.3 * dt
            STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt
          } else {
            STATE.rotation.y += 0.1 * dt
          }
        }

        mainGroup.rotation.y = STATE.rotation.y
        mainGroup.rotation.x = STATE.rotation.x

        // èšç„¦æ¨¡å¼ä¸‹é™ä½æ›å…‰ï¼Œè®©å›¾ç‰‡æ›´æ¸…æ™°å¯è§
        if (STATE.mode === 'FOCUS') {
          renderer.toneMappingExposure = THREE.MathUtils.lerp(
            renderer.toneMappingExposure,
            0.65,
            dt * 2,
          )
        } else {
          renderer.toneMappingExposure = THREE.MathUtils.lerp(
            renderer.toneMappingExposure,
            2.2,
            dt * 2,
          )
        }

        particleSystem.forEach((p) => p.update(dt, STATE.mode, STATE.focusTarget))
        composer.render()
      }

      // init() å·²åœ¨èµ„æºåŠ è½½å®Œæˆåè‡ªåŠ¨è°ƒç”¨
    </script>
  </body>
</html>
